# 입실 체크 해주세요 !! 🔮
# 금일 수업 계획
1. 서드파티 컴포넌트
  - React date picker를 통한 서드파티 컴포넌트 설치
  - AG Grid를 이용한 페이지네이션 및 필터링
  - MUI 컴포넌트 이용 라이브러리를 위한 CSS
2. SpringBoot 연동
# full stack 이후 수업 관련 사항
1. Docker 배포
2. Github 팀 관련 수업
3. AWS 배포

# 대기 동안에 새 프로젝트 생성하겠습니다.
1. React-TypeScript로 thirdpartyapp 생성하시오.
2. App.tsx를 초기화 하시오.

# third party components
chrome -> awesome-react-components
https://github.com/brillout/awesome-react-components

1. 컴포넌트들은 README에서 볼 수 있듯이 npm을 통해서 설치가 가능합니다.
- 설치 방법 :
`npm install component_name@version`
`npm install react-date-picker@10.0.3`
- 설치된 컴포넌트를 리액트 앱에서 제거하는 명령어
`npm uninstall component_name`
`npm uninstall react-date-picker`
- 업데이트가 누락된 컴포넌트들을 전부 다 검색하는 명령어
`npm outdated`
- 업데이트 누락된 컴포넌트들을 일괄 업데이트하는 명령어
`npm update`
- 모든 프로젝트 의존성 목록을 가져오는 명령어
`npm list`

# AG Grid
`npm install ag-grid-community@30.1.0 ag-grid-react@30.1.0`
AG Grid는 리액트 앱을 위한 데이터 그리드 컴포넌트입니다.
- 스프레드 시트처럼 데이터를 표시하는 데 이용하며, 상호작용도 가능합니다.
- 필터링 / 정렬 / 피벗과 같은 기능들을 포함했습니다.

```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
import './App.css'

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
};

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]); 

  const handleClick = () => {
    axios.get<{ items : Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(reponse => setRepodata(reponse.data.items))
    .catch(error => console.log(error))
  }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search📍</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
      >
        <AgGridReact rowData={repodata}/>
      </div>
    </div>
  )
}

export default App
```
```tsx
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
```
이상의 import 문들은 ag-grid 컴포넌트 자체와 스타일시트를 가지고 왔습니다. 그 중에서도 83 번 라인은, google에서 권장하는 material style을 가지고 왔음을 뜻합니다.

그러니까 사전 정의 스타일을 가지고 옴으로써 css를 최소화했습니다.
그런데 styles/ag-grid.css를 통해 최소한의 커스터마이징도 할 수 있는데, 이를 style={{height:500, width:850}}으로 처리했습니다.

그리고 return문에 AgGridReact 컴포넌트의 추가를 통해 repoData를 가지고 테이블을 작성하려합니다.
rowData라고 이미 사전에 이름 붙여져있는 속성에 프롭을 전달했습니다(props drilling 개념). rowData는 객체의 배열을 데이터에 넣을 수 있도록 지원합니다.

그리고 ag-grid 컴포넌트 자체는 스타일을 정의하는 div element로 꼭 감싸줘야만 하기 때문에
```tsx
  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search📍</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
      >
        <AgGridReact rowData={repodata}/>
      </div>
    </div>
  )
```
이상과 같은 return 문이 작성되었습니다.

그 다음 과정으로 ag-grid에 이용될 컬럼을 정의할겁니다. 컬럼 정의 객체의 배열에 해당하는 columnDefs라는 상태를 정의할겁니다. 그리고 ag-grid는 여기에 이용할 수 있는 ColDef 타입을 제공합니다(TypeScript로 쓰는 이유). 컬럼 객체에서는 필수 field 프롭을 이용하여 데이터 접근자를 정의해야하는데, 여기서는 field 값이 컬럼이 표시해야 하는 REST API 응답 데이터의 속성 이름이 될겁니다.

```tsx
import { useState } from 'react'
import axios from 'axios'
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
import './App.css'
import { ColDef, ICellEditorParams } from 'ag-grid-community';

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
};

function App() {
  const [ keyword, setKeyword ] = useState('');
  const [ repodata, setRepodata ] = useState<Repository[]>([]); 
  const [ columnDefs ] = useState<ColDef[]>([
    {field: 'id', sortable: true, filter: true},              // 컬럼1
    {field: 'full_name', sortable: true, filter: true},       // 컬럼2
    {field: 'html_url', sortable: true, filter: false},       // 컬럼3
    {
      field: 'full_name',
      cellRenderer: (params: ICellEditorParams) => (
        <button
          onClick={() => alert(params.value)}
        >
          Press Me ! 📌
        </button>
      )
    }
  ])

  const handleClick = () => {
    axios.get<{ items : Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
    .then(reponse => setRepodata(reponse.data.items))
    .catch(error => console.log(error))
  }

  return (
    <div className="App">
      <input type="text" onChange={e => setKeyword(e.target.value)} value={keyword}/>
      <button onClick={handleClick}>Search📍</button>
      <div className="ag-theme-material"
        style={{height: 500, width: 850}}
      >
        <AgGridReact 
          rowData={repodata}
          columnDefs={columnDefs}
          pagination={true}
          paginationPageSize={5}  
        />
      </div>
    </div>
  )
}

export default App
```

이상에서 컬럼의 정의 및 거기에 딸려있는 properties를 확인했습니다. sortable / filter였고, 그 다음에 추가적인 컬럼을 정의했는데, 거기에 cellRenderer라는 속성이었습니다.

그리고 pagenation / pagenamtionPageSize는 `<AgGridReact>` 컴포넌트 내부에 정의했었습니다. return문과 colDefs 상태를 둘 다 잘 확인하시기 바랍니다.

cellRenderer 프롭을 이용하면 테이블 셀의 컨텐츠를 사용자 정의할 수 있습니다. 이상의 예시에서는 Ag Grid 내의 컬럼에서 버튼을 렌더링하는 예시였습니다.

cellRenderer 속성의 value는 callback 함수로 이루어져있습니다. 그리고 매개변수로 params를 받았고, ICellRenderParams Type으로 작성했고, params.value의 값은 field 속성에 정의된 full_name을 썼습니다. 그래서 버튼 누르면 full_name이 출력되었었습니다.

근데 보니까 컬럼 이름이 너무 대놓고 field와 동일하게만 되어있습니다. 그러다보니까 column명을 확인해보시면 Id / Full_name / Html_url / Full_name으로 Full_name 컬럼이 두 개인 것을 확인할 수 있습니다. 이를 수정하기 위해서는 `headerName` 속성을 활용할 수 있습니다.


# Material UI Component 이용
shoppinglist 프로젝트를 생성하시오. 
React - TypeScript 쓸겁니다.
App.tsx 전부 초기화합니다.
npm install @mui/material@5.14.8 
npm install @emotion/react@11.11.1 
npm install @emotion/styled@11.11.0

```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'

function App() {

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App
```

이상에서 주의깊게 보셔야할 부분은 각 컴포넌트가 뭇느 역할을 하는지 입니다.
Container는 전체 브라우저 화면을 의미하고, AppBar는 상단을 의미합니다. 그리고 ToolBar는 그 중에서도 nav와 비슷한 역할을 합니다.
Typography는 글씨 관련 영역을 나타냅니다.

이하부터는 실제 shopping list의 기능과 관련된 부분을 작성할 예정입니다.
당연히 MUI를 도입한 부분이 될 것이기 때문에 일반적인 html + css + js + react의 형태로는 어떻게 작성될 수 있을지 감안한 상태에서 코드를 확인하셔야 합니다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";

function AddItem(props) {
  const [ open, setOpen ] = useState(false);

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return(
    <>
    </>
  );
}
```
App 컴포넌트 내에 AddItem 컴포넌트를 추가할겁니다. 그런데 저희 todolist할 때는 input창에 button 하나만 있었습니다. 그리고 github api 가지고 올 때도 그랬었구요. 이번에는 Modal이라고 하는 개념을 추가할겁니다.
근데 이 Modal을 저희가 처음 배우는건 아니고 1만 시간의 법칙에서 했었습니다.

폼에 product와 amount라는 두 개의 입력 필드와 App 컴포넌트 내에 addItem 함수를 호출하는 버튼을 추가할겁니다. _App 컴포넌트에 있는 addItem 함수를 호출할 수 있으려면 addItem 컴포넌트를 렌더링할 때 프롭으로 전달_ 해야합니다. 모달 Dialog 컴포넌트 외부에 사용자가 새 쇼핑항목을 입력할 수 있는 모달 폼을 여는 버튼을 추가해둘겁니다. 해당 버튼은 컴포넌트가 처음 렌더링 될 때 보이는 유일한 요소에 해당할겁니다.
즉 최초에 open 상태가 false이기 때문에 모달 폼은 보이지 않고, 버튼만 보일것이라는 의미입니다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

function AddItem(props) {
  const [ open, setOpen ] = useState(false);
  const [ item, setItem ] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  return(
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>

        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  );
}

export default AddItem
```
이상에서 일단 주의해서 봐야할 점은 App.tsx에 정의되어있는 type인 Item을 가지고 왔다는 점입니다. 이 것은 프로젝트의 사이즈가 매우 작기 때문이고, 보통은 types.ts 파일에 전체 타입들이 정의되어있고, 거기서 가지고 오게 될겁니다.

그리고 addItem함수가 App.tsx에 정의되어있지만, AddItem 컴포넌트에서 불러오고 있습니다. 이 부분에 대해서 의문을 가질 수 있습니다.
1. AddItem 컴포넌트 내에 addItem 함수를 정의하면 안되는가.
  - App.tsx의 addItem 함수를 확인하면 Item이 추가되고, 기존의 items들을 그대로 스프레드 연산자로 받아온다는 것을 확인할 수 있습니다.
  - 여기서 중요한 점은 AddItem 컴포넌트에서 하나의 item을 추가한 것을 상위로 보낼 방법이 없다는 점입니다.
  - React에서의 Data Flow는 상위->하위로 이어지는 Top-Down 형식이기 때문입니다. 즉 AddItem 컴포넌트에서 추가하는 함수를 별개로 만들어봤자 App 컴포넌트로 보낼 수 없기 때문에 결과적으로 App 컴포넌트에서 addItem 함수를 만들고, _해당 함수를 호출하는 함수를 AddItem 컴포넌트에 정의_ 해야한다고 생각할 수 있겠습니다.
  - React에서의 기초적인 원리 부분에서 One-way data flow에 대해 강조한 이유가 나오는 부분 중 하나입니다.
  - 이게 너무 머리 아프면 Recoil / ContextAPI 등의 전역 상태 관리를 통해서 함수를 전부 다 전역에 등록해서 불러오는 방법도 고려할 수 있습니다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from "@mui/material";
import { useState } from "react";
import { Item } from "./App";

type AddItemProps = {
  addItem: (item: Item) => void;
}

function AddItem(props: AddItemProps) {
  const [ open, setOpen ] = useState(false);
  const [ item, setItem ] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  }

  const handleClose = () => {
    setOpen(false);
  }

  // App.tsx의 addItem 함수를 호출하고, item 상태를 전달
  const addItem = () => {
    props.addItem(item);
    // TextField에 있는 내용을 다 지우고 Modal을 닫음
    setItem({product: '', amount: ''});
    handleClose();
  }

  return(
    <>
      <Button onClick={handleOpen}>
        Add Item
      </Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>
          <TextField value={item.product} margin="dense"
            onChange={e => setItem({...item, product: e.target.value})}
            label="Product/제품명" fullWidth />
          <TextField value={item.amount} margin="dense"
            onChange={e => setItem({...item, amount: e.target.value})}
            label="Amount/수량" fullWidth
          />
        </DialogContent>
        <Button onClick={handleClose}>
          Cancel / 취소
        </Button>
        <Button onClick={addItem}>
          Add / 저장
        </Button>
      </Dialog>
    </>
  );
}

export default AddItem
```

이상의 코드에서 props로 전달하는 함수 부분에 주목하셔야 합니다. 이를 위해 AddItemProps라는 type을 선언했습니다.

마찬가지로,
App.tsx도 확인하셔야 합니다. 함수를 전달하기 위한 방식이었습니다.
```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import './App.css'
import { useState } from 'react';
import AddItem from './AddItem';

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [ items, setItems ] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setItems([item, ...items]);
  }

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem}/>
    </Container>
  )
}

export default App

```

그렇다면 현재까지 작성한 것을 기준으로 했을 때 App.tsx에 있는 items 상태가 업데이트 된다는 것은 확인할 수 있습니다.

근데 그 업데이트된 items를 보여주지 못하고 있네요.
그럼 업데이트된 items의 결과를 보여주는 return부분에서의 코드가 있어야 할 것 같습니다.

```tsx
import { Container } from '@mui/material'
import {AppBar, Toolbar, Typography} from '@mui/material'
import {List, ListItem, ListItemText } from '@mui/material';
import './App.css'
import { useState } from 'react';
import AddItem from './AddItem';

export type Item = {
  product: string;
  amount: string;
}

function App() {
  const [ items, setItems ] = useState<Item[]>([]);
  const addItem = (item:Item) => {
    setItems([item, ...items]);
  }

  return (
    <Container>
      <AppBar position="static">
        <Toolbar>
          <Typography variant='h6'>
            쇼핑 리스트 Shopping List
          </Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem}/>
      <List>
        {
          items.map((item, index) =>
            <ListItem key={index} divider>
              <ListItemText 
                primary={item.product}
                secondary={item.amount}/>
            </ListItem>
          )
        }
      </List>
    </Container>
  )
}

export default App
```
이상에서 확인해야 하는 점은 기본적으로 items 상태를 업데이트 하는 부분이 어느 부분에 작성되어야 하는가입니다. 구조는 현재
App
 ↓
AddItem
컴포넌트 구조로 되어있습니다. 즉, App 컴포넌트에 items 결과값을 표시할 것이냐, AddItem 컴포넌트에 표시할 것이냐 1/2 확률이라고 볼 수 있겠네요.

심플하게 생각해봤을 때, items 상태가 정의된 곳이 어디죠?
App
그래서 App에 결과값 표시했습니다.

List 컴포넌트를 App 컴포넌트 내에서 렌더링했습니다. 지금 현재까지 MUI를 보시면 위계가 잡혀있다는 것을 알 수 있습니다.
List -> ListItem -> ListItemText
ul -> li
List 내에서 map() 함수를 활용하여 ListItem 컴포넌트를 생성했습니다(ul 내부에서 map함수 써서 li를 만든 것과 동일합니다). 배열이기 때문에 key 프롭이 요구되는 것도 동일합니다.
그리고 `<ListItem key={index} divider>`에서 보시면 divider라는 속성이 있는데, 얘는 각 항목 끝부분에 구분선을 가지고 옵니다.
다음에 ListItemText에서 기본 텍스트로 product를 표시하고, 보조 텍스트로 amount를 표시했습니다. 각각 primary / secondary로 쓰였습니다. MUI에서 자주 쓰이는 속성입니다.

또한 button의 스타일이 있는데, variant="outlined/text/contained"로 쓸 수 있습니다.

이상의 MUI 라이브러리를 사용하면 리액트 앱에서 일관되게 디자인을 하는 것이 가능합니다. 그리고 좋은 점은 프로젝트를 찍어낼 때 CSS를 고려할 필요성이 덜하다는 점이죠.

하지만 기본값이 정해져있는만큼 커스터마이징을 하기 위해서는 emotion이나 tailwind를 고려할 필요도 있습니다.

밥 먹고 다음 시간에는 React Router를 활용하여 라우팅 관리를 하는 법을 수업하겠습니다.

# React Router
routerapp project를 생성 React / TypeScript
npm install
npm install react-router-dom@6
App.tsx를 초기화
Home.tsx를 생성하고 초기화
Contact.tsx를 생성하고 초기화

React Router란 URL을 기반으로 특정 컴포넌트를 렌더링할지 정의할 수 있는 방식

react-router-dom 라이브러리는 라우팅을 구현하는 데 이용되는 컴포넌트들을 제공합니다.
1. BrowserRouter : 웹 기반 애플리케이션을 위한 라우터
2. Route : 주어진 위치가 일치하면 정의된 컴포넌트를 렌더링
이하는 Route 컴포넌트의 예시인데, element 속성은 사용자가 path 프롭에 정의된 contact 엔드포인트로 이동할 때 렌더링되는 컴포넌트를 정의합니다. 경로는 현재 위치를 기준으로 상대 경로를 작성합니다.
`<Route path="contact" element={<Contact />} />`
혹은 이하와 같이 path 속성 끝에 * 와일드카드를 이용하는 것도 가능합니다.
`<Route path="/contact/*" element={<Contact />} />`
그러면 contact/mike 혹은 contact/1 등의 엔드포인트들에 전부 다 Contact 컴포넌트가 렌더링됩니다.
또한, Route 컴포넌트는 여러 Route 컴포넌트를 감싸는 것이 가능합니다. 이를 위해서 Link 컴포넌트는 애플리케이션에 대한 탐색 기능을 제공하는데, 이하의 예시는 Contact 링크를 표시하며, 해당 링크를 클릭했을 때 `/contact` 엔드포인트로 이동합니다.
`<Link to="/contact">Contact</Link>`

```tsx
//App.tsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'
import Home from './Home'
import Contact from './Contact'
import './App.css'
import PageNotFound from './PageNotFound'
import ContactSeoul from './ContactSeoul'
import ContactBusan from './ContactBusan'

function App() {

  return (
    <>
      <BrowserRouter>
        <nav>
          <Link to="/">Home</Link>{' | '}
          <Link to="/contact">Contact</Link>
        </nav>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="contact" element={<Contact />}>
            <Route path="seoul" element={<ContactSeoul />} />
            <Route path="busan" element={<ContactBusan />} />
          </Route>
          <Route path="*" element={<PageNotFound />} />
        </Routes>
      </BrowserRouter>
    </>
  )
}

export default App


// Contact.tsx
import { Link, Outlet } from "react-router-dom";


function Contact() {

  return(
    <>
      <h3>Contact Us ! ⭐</h3>
      <nav>
        <Link to="seoul">서울 지점</Link> {' | '}
        <Link to="busan">부산 지점</Link>
      </nav>
      <hr />
      <Outlet />
    </>
  );
}

export default Contact
```
`<Outlet />` : 중첩 라우트(Nested Routes)를 렌더링하기 위해 사용하는 일종의 자리 표시자(placeholder)입니다.

그러니까 Outlet 컴포넌트가 있는 장소에 해당 자식 컴포넌트를 불러내주세요, 라는 의미가 됩니다.
그러면 이상의 코드에서 보셨던 것처럼 App.tsx의 `<Route path="contact" element={<Contact />}>`의 내부에 seoul과 busan 엔드포인트를 지정했고, 거기에 ContactSeoul과 ContactBusan을 이미 명시해뒀습니다. 그렇기 때문에 Contact 컴포넌트 내에서 다시 ContactSeoul 및 ContactBusan을 명시하는 것이 아니라 `<Outlet />` 컴포넌트를 통해서 불러온다고 생각하시면 됩니다.

이상의 라이브러리를 이용할 경우 컴포넌트들이 하나의 URL(예를 들어 localhost:5173)만 가지는 것이 아니라 각각의 다른 URL을 가지도록 통제하여 필요한 부분만을 렌더링할 수 있도록 합니다.

# 금일 현재까지의 학습 내용 요약
1. 3rd party 컴포넌트들을 학습했습니다.
  - react-date-picker는 그냥 설치하는 방법 보여드렸습니다.
  - AgGrid를 이용했습니다.
    - 테이블을 대체하는 컴포넌트
      - filter, sort, column 정의와 관련된 부분을 학습했습니다.
  - MUI 컴포넌트
    - 이상에서 중요한 것은 각각의 HTML 태그에 해당하는 컴포넌트들이 존재한다는 점입니다.
      - `<input>` 태그를 대체하는 것은 `<TextField>`인 등
      - 내부에 MUI 자체 property가 있기 때문에 학습 필요성이 있습니다.
      - 귀찮게 하나하나 학습할거면 왜 쓰냐 싶은데 이게 CSS 보다 훨씬 쉬워서 그렇습니다.
  - react-router-dom
    - SPA 상에서 하나의 URL이 아니라 다수의 URL을 다루는 방식을 학습했습니다.
    - 조건부 렌더링이 if문이나 삼항연산자를 쓰는 것 뿐만 아니라, 내부의 URL을 기준으로 서로 다른 컴포넌트를 렌더링할 수 있도록 하는 방식이었습니다.

외부 라이브러리를 다루는 현재 시점에서는 제 수업 자체보다는 공식문서의 활용이 매우 중요합니다. 여러분들이 프로젝트 때 어떤 라이브러리를 다루게 될 지 모르니까요.

# Full Stack 개발 - 스프링부트 RESTful API 웹 서비스를 위한 프론트엔드
## UI prototype
1. 데이터베이스의 자동차를 테이블에 나열하고, 페이징, sorting, filtering 기능을 구현할겁니다 - AG Grid를 써서
2. 데이터베이스에 새 차량을 추가할 수 있는 모달 폼을 여는 버튼을 구현할겁니다. - MUI를 사용해서
3. 차량 테이블의 각 행에 자동차를 편집하거나 데이터베이스에서 삭제하는 버튼을 구현할겁니다. AG Grid에 있었는데, 거기에 버튼을 클릭했을 때 특정 함수가 호출되고, 그게 백엔드로 전달 -> DB로 들어가서 PUT 혹은 DELETE 메서드를 실행시킬겁니다.
4. CSV 파일로 변형하여 내려받기가 가능한 링크 혹은 버튼을 구현해볼까 합니다.

## FrontEnd React 프로젝트 생성
carfront project를 생성합니다 React / TypeScript
npm install
npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @mui/material@5.17.1
npm install @tanstack/react-query@4.36.1
npm install axios@1.9.0
App.tsx를 전체 초기화
npm run dev
git add .
git commit -m "feat: carfront project creation"
git push


```tsx
import { AppBar, Toolbar, Typography, Container, CssBaseline } from "@mui/material"

function App() {

  return (
    <Container maxWidth="xl">
      <CssBaseline />
      <AppBar position="static">
        <Toolbar>
          <Typography variant="h6">
            Car Shop
          </Typography>
        </Toolbar>
      </AppBar>
    </Container>
  )
}

export default App
```
Container : 앱 컨텐츠를 가로로 중앙에 배치하는 기본 레이아웃 컴포넌트 
AppBar : position 속성을 이용하여 앱 바가 어떻게 자리 잡을지 정의(static으로 잡았습니다).
  static 값은 사용자가 스크롤할 때 앱 바가 상단에 고정되지 않음.
  fixed를 사용하면 상단에 고정됩니다.
Container의 maxWidth 속성은 앱의 최디 너비를 정의하며, 가장 큰 값을 사용했습니다.
CssBaseline : 브라우저 간의 css 속성의 차이를 수정하는 데 이용하는 컴포넌트로 여러 브라우저에서 리액트 앱의 모양이 동일하게 보이게끔 설정했습니다. 이 컴포넌트는 일반적으로 최상위 레벨에 포함되어 스타일이 전역적으로(css의 의미 생각하셔야 합니다) 적용되게끔 합니다.

# CRUD 기능의 Frontend version

현재에서의
http://localhost:8080/api/cars
```json
{
    "_embedded": {
        "cars": [
            {
                "brand": "Kia",
                "model": "Seltos",
                "color": "Chacol",
                "registrationNumber": "370SU5690",
                "modelYear": 2020,
                "price": 30000000,
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/cars/1"
                    },
                    "car": {
                        "href": "http://localhost:8080/api/cars/1"
                    },
                    "owner": {
                        "href": "http://localhost:8080/api/cars/1/owner"
                    }
                }
            },
            {
                "brand": "Hyundai",
                "model": "Sonata",
                "color": "White",
                "registrationNumber": "123456",
                "modelYear": 2025,
                "price": 25000000,
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/cars/2"
                    },
                    "car": {
                        "href": "http://localhost:8080/api/cars/2"
                    },
                    "owner": {
                        "href": "http://localhost:8080/api/cars/2/owner"
                    }
                }
            },
            {
                "brand": "Honda",
                "model": "CR-V",
                "color": "Black-White",
                "registrationNumber": "987654",
                "modelYear": 2024,
                "price": 45000000,
                "_links": {
                    "self": {
                        "href": "http://localhost:8080/api/cars/3"
                    },
                    "car": {
                        "href": "http://localhost:8080/api/cars/3"
                    },
                    "owner": {
                        "href": "http://localhost:8080/api/cars/3/owner"
                    }
                }
            }
        ]
    },
    "_links": {
        "self": {
            "href": "http://localhost:8080/api/cars?page=0&size=20"
        },
        "profile": {
            "href": "http://localhost:8080/api/profile/cars"
        },
        "search": {
            "href": "http://localhost:8080/api/cars/search"
        }
    },
    "page": {
        "size": 20,
        "totalElements": 3,
        "totalPages": 1,
        "number": 0
    }
}
```
cars 배열은 _embedded.cars 노드에서 확인할 수 있습니다.

React query를 이용하여 네트워크를 구현하기 위해 npm install을 했었습니다.

## Backend에서 데이터 가져 오기

현재 타입스크립트를 사용하고 있기 때문에 Car 데이터의 타입을 정의해야 합니다. 그래서 타입을 정의하는 새 파일들을 다 모아놓고, 거기서 필요한 타입들만 import해서 빼올 수 있도록 하겠습니다.

src -> types.ts 파일 만들겠습니다.
그리고 자동차 객체는 어떻게 생겨야하는지를 확인하기 위해 GET 요청 상에서의 JSON 형태를 확인하셔야 합니다.
```json
{
  "brand": "Honda",
  "model": "CR-V",
  "color": "Black-White",
  "registrationNumber": "987654",
  "modelYear": 2024,
  "price": 45000000,
  "_links": {
      "self": {
          "href": "http://localhost:8080/api/cars/3"
      },
      "car": {
          "href": "http://localhost:8080/api/cars/3"
      },
      "owner": {
          "href": "http://localhost:8080/api/cars/3/owner"
      }
  }
}
```

```ts
export type CarResponse = {
  brand: string;
  model: string;
  color: string;
  registrationNumber: string;
  modelYear: number;
  price: number;
  _links: {
    self: {
      href: string;
    }, 
    car : {
      href: string;
    }, 
    owner: {
      href: string;
    }
  }
}
```
json에서의 자동차 element를 확인하여 프론트엔드 상에서의 CarResponse type을 정의했습니다. 여러 대의 차를 가지고 오고 싶으면 CarResponse[]가 되겠네요.

이후에 뭐할거냐면 localhost:8080/api/cars 엔드포인트에서 GET 요청을해서 백엔드에서 자동차들을 가지고 올겁니다. 그러면 함수가 있어야겠네요.

Carlist.tsx에 작성합니다.
```tsx
import { CarResponse } from "../types";
import axios from "axios";
import { useQuery } from "@tanstack/react-query";

function Carlist() {
  const getCars = async (): Promise<CarResponse[]> => {
    const response = await axios.get("http://localhost:8080/api/cars");

    return response.data._embedded.cars;
  }

  const { data, error, isSuccess } = useQuery({
    queryKey: ["cars"],
    queryFn: getCars
  });

  if(!isSuccess) {
    return <span>Loading... 🔮</span>
  }

  if (error) {
    return <span>자동차들을 불러오는 데 실패했습니다. 😱</span>
  }
  else {
    return (
      <table>
        <tbody>
          {
            data.map((car: CarResponse) =>
              <tr key={car._links.self.href}>
                <td>{car.brand}</td>
                <td>{car.model}</td>
                <td>{car.color}</td>
                <td>{car.registrationNumber}</td>
                <td>{car.modelYear}</td>
                <td>{car.price}</td>
              </tr>
            )
          }
        </tbody>
      </table>
    )
  }
}

export default Carlist
```


# React Hook 관련 자료
https://paullabworkspace.notion.site/React-Hook-973d46042bf14d4eb6baeb90ac2ca09e

git add .
git commit -m "feat: 20251020 frontend RESTful API / AG Grid / MUI"
git push
자격 증명 삭제
자리 정리
OAuth2 구현